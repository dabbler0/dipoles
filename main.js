// Generated by CoffeeScript 1.8.0
(function() {
  var ANGLE, C, Dipole, Q, RMAX, RMIN, S, THETA, Vector, angleElement, cElement, canvas, ctx, functionElement, k, qElement, render, rmaxElement, rminElement, sElement, thetaElement, thetaRangeElement, ymax, ymin;

  Vector = (function() {
    function Vector(x, y) {
      this.x = x;
      this.y = y;
    }

    Vector.prototype.minus = function(other) {
      return new Vector(this.x - other.x, this.y - other.y);
    };

    Vector.prototype.plus = function(other) {
      return new Vector(this.x + other.x, this.y + other.y);
    };

    Vector.prototype.times = function(scalar) {
      return new Vector(this.x * scalar, this.y * scalar);
    };

    Vector.prototype.magnitude = function() {
      return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));
    };

    Vector.prototype.distance = function(other) {
      return this.minus(other).magnitude();
    };

    Vector.prototype.unit = function() {
      return this.times(1 / this.magnitude());
    };

    return Vector;

  })();

  Dipole = (function() {
    function Dipole(q, s) {
      this.q = q;
      this.s = s;
      this.pos = new Vector(-this.s / 2, 0);
      this.neg = new Vector(this.s / 2, 0);
    }

    Dipole.prototype.field = function(r, theta) {
      var location, negMag, negUnit, negVector, posMag, posUnit, posVector, sum;
      location = new Vector(r * Math.cos(theta), r * Math.sin(theta));
      posMag = Dipole.COULOMB_CONSTANT * this.q / Math.pow(location.distance(this.pos), 2);
      negMag = Dipole.COULOMB_CONSTANT * -this.q / Math.pow(location.distance(this.neg), 2);
      posUnit = location.minus(this.pos).unit();
      negUnit = location.minus(this.neg).unit();
      posVector = posUnit.times(posMag);
      negVector = negUnit.times(negMag);
      sum = posVector.plus(negVector);
      return {
        m: sum.magnitude(),
        angle: Math.atan2(sum.y, sum.x)
      };
    };

    return Dipole;

  })();

  k = Dipole.COULOMB_CONSTANT = 8.987e9;

  canvas = document.querySelector('canvas');

  ctx = canvas.getContext('2d');

  canvas.width = canvas.height = 500;

  ymin = ymax = null;

  render = function(q, s, rmin, rmax, theta) {
    var dipole, el, i, r, second_y_array, t, x_array, y_array, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _ref3;
    console.log('JUST RENDERED', q, s, rmin, rmax, theta);
    dipole = new Dipole(q, s);
    x_array = [];
    y_array = [];
    second_y_array = [];
    if (thetaRangeElement.checked) {
      for (t = _i = _ref = -Math.PI, _ref1 = Math.PI, _ref2 = 2 * Math.PI / canvas.width; _ref2 > 0 ? _i < _ref1 : _i > _ref1; t = _i += _ref2) {
        x_array.push(t);
        if (ANGLE) {
          y_array.push(dipole.field(rmax, t).angle);
        } else {
          y_array.push(dipole.field(rmax, t).m);
        }
        if (functionElement.value.length > 0) {
          second_y_array.push(eval(functionElement.value));
        }
      }
    } else {
      for (r = _j = rmin, _ref3 = (rmax - rmin) / canvas.width; _ref3 > 0 ? _j < rmax : _j > rmax; r = _j += _ref3) {
        x_array.push(r);
        if (ANGLE) {
          y_array.push(dipole.field(r, theta).angle);
        } else {
          y_array.push(dipole.field(r, theta).m);
        }
        if (functionElement.value.length > 0) {
          second_y_array.push(eval(functionElement.value));
        }
      }
    }
    ymin = 0;
    ymax = Math.max.apply(this, y_array);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (ANGLE) {
      ymin = -Math.PI;
      ymax = Math.PI;
      ctx.font = '20px Arial';
      ctx.fillText('\u03C0', 0, 20);
      ctx.fillText('-\u03C0', 0, canvas.height - 40);
    } else {
      ctx.font = '20px Arial';
      ctx.fillText(ymax.toPrecision(3) + 'N/C', 0, 20);
      ctx.fillText(ymin.toPrecision(3) + 'N/C', 0, canvas.height - 40);
    }
    if (thetaRangeElement.checked) {
      ctx.fillText('-\u03C0', 20, canvas.height - 20);
      ctx.fillText('\u03C0', canvas.width - ctx.measureText('-\u03C0').width, canvas.height - 40);
    } else {
      ctx.fillText(RMIN.toPrecision(3) + 'm', 20, canvas.height - 20);
      ctx.fillText(RMAX.toPrecision(3) + 'm', canvas.width - ctx.measureText(RMAX.toPrecision(3) + 'm').width, canvas.height - 20);
    }
    ctx.beginPath();
    ctx.moveTo(0, canvas.height * (1 - (y_array[0] - ymin) / (ymax - ymin)));
    for (i = _k = 0, _len = y_array.length; _k < _len; i = ++_k) {
      el = y_array[i];
      ctx.lineTo(i, canvas.height * (1 - (el - ymin) / (ymax - ymin)));
    }
    ctx.strokeStyle = '#000';
    ctx.stroke();
    if (second_y_array.length > 0) {
      ctx.beginPath();
      ctx.moveTo(0, canvas.height * (1 - (second_y_array[0] - ymin) / (ymax - ymin)));
      for (i = _l = 0, _len1 = second_y_array.length; _l < _len1; i = ++_l) {
        el = second_y_array[i];
        ctx.lineTo(i, canvas.height * (1 - (el - ymin) / (ymax - ymin)));
      }
      ctx.strokeStyle = '#F00';
      return ctx.stroke();
    }
  };

  rminElement = document.querySelector('#rmin');

  rmaxElement = document.querySelector('#rmax');

  thetaElement = document.querySelector('#theta');

  thetaRangeElement = document.querySelector('#thetarange');

  functionElement = document.querySelector('#function');

  angleElement = document.querySelector('#angle');

  qElement = document.querySelector('#q');

  sElement = document.querySelector('#s');

  cElement = document.querySelector('#C');

  ANGLE = false;

  RMIN = 0;

  RMAX = 10;

  THETA = Math.PI / 4;

  Q = 1e-9;

  S = 1;

  C = 0;

  rminElement.addEventListener('input', function() {
    RMIN = Number(rminElement.value);
    return render(Q, S, RMIN, RMAX, THETA);
  });

  rmaxElement.addEventListener('input', function() {
    RMAX = Number(rmaxElement.value);
    return render(Q, S, RMIN, RMAX, THETA);
  });

  thetaElement.addEventListener('input', function() {
    THETA = Number(thetaElement.value) * Math.PI / 180;
    return render(Q, S, RMIN, RMAX, THETA);
  });

  qElement.addEventListener('input', function() {
    Q = Number(qElement.value);
    return render(Q, S, RMIN, RMAX, THETA);
  });

  sElement.addEventListener('input', function() {
    S = Number(sElement.value);
    return render(Q, S, RMIN, RMAX, THETA);
  });

  functionElement.addEventListener('input', function() {
    S = Number(sElement.value);
    return render(Q, S, RMIN, RMAX, THETA);
  });

  thetaRangeElement.addEventListener('change', function() {
    return render(Q, S, RMIN, RMAX, THETA);
  });

  angleElement.addEventListener('change', function() {
    console.log('changed...');
    if (angleElement.value === 'angle') {
      ANGLE = true;
    } else {
      ANGLE = false;
    }
    return render(Q, S, RMIN, RMAX, THETA);
  });

  render(Q, S, RMIN, RMAX, THETA);

  canvas.addEventListener('mousemove', function(event) {
    if (thetaRangeElement.checked) {
      return canvas.setAttribute('title', "(" + (event.offsetX * 2 * Math.PI / canvas.width - Math.PI) + ", " + (event.offsetY * (ymax - ymin) / canvas.height + ymin) + ")");
    } else {
      return canvas.setAttribute('title', "(" + (event.offsetX * (RMAX - RMIN) / canvas.width + RMIN) + ", " + (event.offsetY * (ymax - ymin) / canvas.height + ymin) + ")");
    }
  });


  /*
  generate = (q, s, rmin, rmax) ->
    dipole = new Dipole q, s
  
     * Along the x-axis
    rows = []
    for r in [rmin...rmax] by (rmax - rmin) / 100
      {m, angle} = dipole.field r, 0
      rows.push [r, m]
    fs.writeFileSync 'x-axis.csv', rows.map((row) -> row.join(',')).join('\n')
  
     * Along the x-axis
    rows = []
    for r in [rmin...rmax] by (rmax - rmin) / 100
      {m, angle} = dipole.field r, Math.PI / 2
      rows.push [r, m]
    fs.writeFileSync 'y-axis.csv', rows.map((row) -> row.join(',')).join('\n')
  
     * Along the line x = y
    rows = []
    for r in [rmin...rmax] by (rmax - rmin) / 100
      {m, angle} = dipole.field r, Math.PI / 2
      rows.push [r, m, angle]
    fs.writeFileSync 'xy.csv', rows.map((row) -> row.join(',')).join('\n')
  
     * vs theta (symmetric after pi)
    rows = []
    for t in [0...Math.PI] by Math.PI / 100
      {m, angle} = dipole.field rmax, t
      rows.push [t, m, angle]
    fs.writeFileSync 'theta.csv', rows.map((row) -> row.join(',')).join('\n')
  
   * We examine a dipole of two protons a millimeter apart.
  fs = require 'fs'
  generate 1.6e-19, 0.01, 0.011, 0.2
   */

}).call(this);
